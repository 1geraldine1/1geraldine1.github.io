---
title: "제로베이스 20220315"
date: 2022-03-15T18:30:00-04:00
categories:
  - '2022-03 TIL'
tags:
  - '20220315'
  - '제로베이스'
  - '제로베이스 데이터사이언스 스쿨'


published: true
---

# 개요

* 오늘은 이번달 말에 있는 제로베이스 교육과정중 코딩테스트 연습 차원에서, 제로베이스 측에서 내준 Programmers 기반의 문제를 풀어보는 시간이 있었다.

* 180분, 10문항.

# 코딩테스트 연습

# 1. [제로베이스 프론트엔드 스쿨_Billboard]

* n개의 문자를 보여주는 크기가 n인 전광판이 있습니다. 전광판의 문자는 오른쪽에서 왼쪽으로 반복해서 흘러가며, 1초에 한 글자씩 흘러갑니다.

* 예를 들어, 크기가 5인 전광판에 "Snowball" 노출한다고 가정할 때, 시간 t의 변화에 따른 노출 예시는 다음과 같습니다.
	```
	t : 0초
	전광판 : .....

	t : 1초
	전광판 : ....S

	t : 5초
	전광판 : Snowb

	t : 10초
	전광판 : all..

	t : 15초
	전광판 : ...Sn
	```

* 전광판의 크기 n과 전광판에 노출할 문자 s 그리고 시간 t가 주어질 때, t 초 후의 전광판에 표시될 문구를 출력하는 함수, solution을 완성해주세요.

## 제한 사항

* 전광판의 문자는 1초부터 흐르기 시작합니다.

## 입력

* n은 1 이상 50 이하의 정수입니다.

* s는 길이가 1 이상 100 이하의 문자열입니다.

* s는 알파벳 대/소문자와 숫자로 구성됩니다.

* t는 1 이상 1000 이하의 정수입니다.

## 출력

* t 초 후, 주어진 전광판에 노출되는 문자를 출력합니다.

* 전광판의 공백은 마침표(".")로 대체하여 출력합니다.

## 풀이

```py
from collections import deque

def solution(n, s, t):

    cnt = 0

    panel = deque(['.'] * n)
    s = (list(s) + ['.'] * n) * t

    for _ in range(0,t):
        if s[0] == ' ':
            panel.append('.')
        else:
            panel.append(s[0])
        del s[0]
        del panel[0]
    return ''.join((list(panel)))
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 크기 n의 큐에 데이터를 넣어주는 느낌으로 풀었다.

* 이번 문제에서는 함정이 두가지 있었다.
	1. 전광판에 전체 문자가 한번 들어갔다 나온 뒤에는 전광판 크기만큼 공백이 들어간다.
		* 입력 예시의 10초와 15초 구간을 통해 유추해야 했다.
	2. 전광판에 들어가는 빈 문자```(' ')```역시 ```(.)```으로 치환해서 넣어야 한다.
		* 글자 중간의 띄어쓰기나 아예 빈문자만 출력하는 등의 입력 예제가 함정으로 숨어있었는지, 첫 제출때는 오답처리가 났었다.



# 2. [제로베이스 프론트엔드 스쿨_BuildPyramid]

* 블록으로 피라미드 모양의 탑을 쌓으려고 합니다. 피라미드 모양의 탑은 꼭대기는 1개의 블록을 사용하고, 그 아래는 2개의 블록, 그 아래에는 3개의 블록의 방식으로 쌓습니다.

* n 층의 피라미드 모양의 탑을 쌓을 때, 필요한 블록의 수를 구하는 함수, solution을 완성해주세요.

* 예를 들어, 4층의 피라미드에는 총 10개의 블록이 필요합니다.

	```
	4층에 사용되는 블록 수 1개
	3층에 사용되는 블록 수 2개
	2층에 사용되는 블록 수 3개
	1층에 사용되는 블록 수 4개
	```
	
* 피라미드에 사용되는 블록의 총수는 10개입니다.


## 입력

* n은 1 이상 1,000 이하의 정수입니다.

## 출력

* 피라미드 모양의 탑을 쌓는데 필요한 블록의 총수를 int 형식으로 출력합니다.

## 풀이

```py
def solution(n):
    # 1차원 피라미드.
    # n층의 피라미드에 필요한 블록 개수는 1~n의 총합.
    # n(n+1)/2로 수식화 가능.

    return n * (n+1) // 2
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 1~n까지의 합을 구하는 문제였다.

* n(n+1)/2 를 프로그램상으로 구현하여 마무리했다.

# 3. [제로베이스 프론트엔드 스쿨_BusStop]

* 도시의 아파트에서 버스 정류장까지 거리를 구하려고 합니다.

* 도시는 격자 모양의 지역으로 구분되어 있으며 아파트는 1로, 버스 정류장은 0으로 표시되어 있습니다.

* 아파트에서 버스 정류장으로 이동은 상하좌우로만 이동할 수 있으며, 대각선으로는 이동이 불가합니다.

* h x w 크기의 도시가 주어질 때, 각 아파트에서 가장 가까운 버스 정류장까지의 거리를 구하는 함수, solution을 완성해주세요.

* 예를 들어, 3 x 3 크기의 도시[[1, 0, 1], [1, 1, 1], [1, 1, 1]]가 주어질 때, 각 아파트에서 가까운 버스 정류장까지의 거리를 나타내는 결과는 [[ 1, 0, 1 ], [ 2, 1, 2 ], [ 3, 2, 3 ]] 입니다.

## 제한 사항

* 도시에서 이동은 상하좌우로만 이동할 수 있으며, 대각선으로는 이동할 수 없습니다.

* 도시에서 버스 정류장은 적어도 하나 이상 존재합니다.

* 도시에는 아파트와 버스 정류장만 존재합니다.


## 입력

* 도시의 정보 city가 주어집니다.

* city는 0과 1로 이루어진 h x w 크기의 2차원 배열입니다.

* 도시의 크기 h와 w는 1 이상 50 이하의 정수입니다.

## 출력

* 아파트에서 버스 정류장까지의 최단 거리를 출력합니다.

* 결과는 h x w 크기의 2차원 배열입니다.

## 풀이

* 풀지 못했다.

## 채점 결과

* 오답(제출 없음) (-/1.0)

## 리뷰

* 이차원 좌표상의 최단거리를 구하는 문제이다.

* 처음에는 이중 반복문으로 정류장의 위치를 구하고, 각 좌표에서 정류장의 좌표를 뺀 값 중에서 최소가 되는 값을 찾아보는 방식으로 접근했다.

* 시간 복잡도 때문에 삼중 반복문은 아닐것이라며 계속 다른 방법을 고민하느라 결국 제출조차 하지 못했다.






# 4. [제로베이스 프론트엔드 스쿨_CalcElectricityFee]

* n개의 방에서 사용한 전기량 usageArr과 전기 요금 fee가 주어질 때, 사용한 모든 전기 요금을 구하는 함수, solution을 완성해주세요.

* 예를 들어, usageArr가 [1, 3, 5] 이고, fee가 5일 때, 총 전기 요금은 45입니다.


## 제한 사항

* 전기 요금 fee는 사용한 전기량 1당 요금입니다.

## 입력

* usageArr는 길이가 1 이상 100 이하의 배열입니다.

* usageArr의 각 요소인 사용한 전기량은 0 이상 100 이하의 정수입니다.

* fee는 1 이상 1,000 이하의 정수입니다.

## 출력

* 사용한 모든 전기 요금을 int 형식으로 출력합니다.

## 풀이

```py
def solution(useageArr, fee):
    # n * fee의 총합
    return sum(useageArr) * fee
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 배열의 합에 요금을 곱하면 끝나는 문제다.

# 5. [제로베이스 프론트엔드 스쿨_Calculator]

* 문자열 계산식을 입력받는 계산기를 만들려고 합니다. 계산식은 덧셈(+), 뺄셈(-), 숫자로만 이루어져 있습니다.
* 계산식 s가 주어질 때, 계산식의 계산 결과를 출력하는 함수, solution을 완성해주세요.

* 예를 들어, s가 -3+26-7로 주어질 때, 계산식의 계산 결과는 16 (-3 + 26 -7)입니다.

## 제한 사항

* 계산식은 덧셈(+), 뺄셈(-), 숫자로만 이루어져 있습니다.

## 입력

* s는 길이가 1 이상 10 이하의 문자열입니다.

## 출력

* 계산식의 계산 결과를 int 형식으로 출력합니다.

## 풀이

```py
def solution(s):
    return eval(s)
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* eval() 함수를 모른다면 코드의 길이가 길어졌을 문제다.


# 6. [제로베이스 프론트엔드 스쿨_AppDesign]

* 앱 디자인을 하려고 합니다. 디자인 영역 area가 주어질 때, 이 영역과 일치하는 사각형의 가로 w와 세로 h를 구하는 함수, solution을 완성해주세요.

* 단, 다음 조건을 만족해야 합니다.

	* 세로 화면 최적화를 위해 가로는 세로보다 길 수 없습니다.

	* 여러 가능한 가로, 세로 조합 중 두 값의 차이가 가장 적은 값을 찾습니다.

* 예를 들어, area가 4일 때, 커버할 수 있는 가로, 세로는 다음과 같습니다.
	```
	가로 w가 1 이고 세로 h가 4인 경우.
	가로 w가 2 이고 세로 h가 2인 경우.
	가로 w가 4 이고 세로 h가 1인 경우는 가로가 세로보다 길기 때문에 제외됩니다.
	이 중, 가로, 세로의 차이가 가장 적은 가로 w가 2, 세로 h가 2인 [2, 2]를 반환합니다.
	```


## 입력

* area는 1 이상 100,000 이하의 정수입니다.

## 출력

* 가로, 세로의 값을 배열로 담은 [w, h]를 반환합니다.

* 가로, 세로는 1 이상 100,000 이하의 정수입니다.

## 풀이

```py
def solution(area):
    # 약수중 가장 차이가 적은 두 값.
    # w <= h

    # 약수 저장 배열
    arr = []

    for i in range(1,area+1):
        if area % i == 0:
            arr.append(i)

    # 약수 개수가 홀수일때. 즉, 어떤 수의 제곱수일때
    if len(arr) % 2 != 0:
        answer = [arr[len(arr)//2], arr[len(arr)//2]]
    else:
        answer = [arr[len(arr)//2-1], arr[len(arr)//2]]

    return answer
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 결국 약수 중에서 가운데에 있는 두 값을 반환하라는 문제다.

* 예시에서도 ```[2,2]```로 보여주었듯, 약수가 홀수인 경우와 짝수인 경우 두가지 경우를 세워 풀어주었다.


# 7. [제로베이스 프론트엔드 스쿨_BinaryDistance]

* 0 이상의 정수 n이 주어질 때, n의 이진 표현에서 인접한 두 1 사이의 가장 긴 거리를 출력하는 함수, solution을 완성해주세요.

* 예를 들어, n이 주어질 때의 결과는 다음과 같습니다.

	```
	n : 5
	n의 이진 표현 : 101
	결과 : 2

	n : 11
	n의 이진 표현 : 1011
	결과 : 2
	```

## 입력

* n은 0 이상 10 ^ 9 이하의 정수입니다.

## 출력

* n의 이진 표현에서 인접한 두 1 사이의 가장 긴 거리를 int 형식으로 출력합니다.

## 풀이

```py
def solution(n):
    binary = str(bin(n))[2:]

    flag = False
    # 간격 저장용 리스트
    arr = []
    cnt = 0
    for c in binary:
        if c == '1' and flag == False:
            flag = True
            cnt += 1
        elif c == '0' and flag == True:
            cnt += 1
        elif c == '1' and flag == True:
            flag = False
            arr.append(cnt)
            cnt = 0

    return max(arr)
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 숫자를 이진수로 표현하는 함수는 bin()이다.
	* 다만, 이 함수를 쓰면 이진수라는 의미로 앞에```0x```가 붙어서 나오므로, 문자열로 변환한 뒤 앞의 두글자를 제거했다.

* 1이 나오면 길이 측정을 시작하여 다음 1이 나오면 측정을 중단하는 방식으로 인접한 두 1사이의 거리를 arr배열에 보관했다.
	* 다만, 위의 코드에서 잘못된 점이 있는데 다시 1이 나오더라도 flag를 False로 만들면 안되는 것이었다.
	* 이 문제에 관해서는 뒤에서 한번 더 언급하겠다.
* arr배열 내부의 최대값을 찾아주는 max()함수로 가장 긴 1의 거리를 반환.



# 8. [제로베이스 프론트엔드 스쿨_Corona]

* 코로나로 인해 건물에 출입하는 인원의 시간을 체크하고 있습니다. 출입 기록인 history에는 출입한 사람의 번호 배열이 저장되어 있습니다.

* history에는 건물에 들어올 때에는 양수가, 나갈 때에는 음수가 기록됩니다.

* 이때, 확진자 번호 infected가 주어질 때, 확진자와 동선이 겹치는 사람의 번호를 오름차순으로 출력하는 함수, solution을 완성해주세요.

* 예를 들어, history가 [3, 2, -3, 1, -1, -2, 4, -4, 1, -1]이고, infected가 2로 주어질 때, 확진자와 동선이 겹치는 사람은 [1, 3]입니다.


## 제한 사항

* 사람은 건물을 여러 번 출입할 수 있습니다.

* 주어지는 history에는 건물에 남아있는 사람이 없습니다.

## 입력

* 출입 기록인 history가 주어집니다.

* history는 1 이상 100 이하의 정수로 이루어진 길이가 1000 이하의 배열입니다.

* 확진자 번호인 infected가 주어집니다.

* infected는 1 이상 100 이하의 정수입니다.

## 출력

* 확진자와 동선이 겹치는 사람의 번호를 오름차순 배열로 출력합니다.

## 풀이

```py
def solution(history, infected):
    # infected가 양수일때 이후에 들어온 사람 및 나가지 않은 사람은 전부 체크.
    # 확진자가 여러번 드나들수 있음을 유의.

    inf_in = []
    inf_out = []


    # 내부 인원 체크
    in_man = []
    # 시간대별 내부 인원 체크
    in_man_per_time = []

    # 확진자 들어온 인덱스 체크 및 건물 내부 인원 체크
    for i in range(0,len(history)):
        if history[i] > 0:
            in_man.append(history[i])
        elif history[i] < 0:
            in_man.remove(-history[i])
        if history[i] == infected:
            inf_in.append(i)
        elif history[i] == -infected:
            inf_out.append(i)

        in_man_per_time.append(list(in_man))

    arr =[]



    for k in range(0,len(inf_in)):
        # 확진자와 동선 겹친 인원들을 산출.
        for num in (history[inf_in[k]+1:inf_out[k]]):
            if abs(num) not in arr:
                arr.append(abs(num))

    # 확진자가 있던 시간대에 건물 내부 인원까지 추가.
    for in_man_time in in_man_per_time[inf_in[k]+1:inf_out[k]]:
        for num in in_man_time:
            if num != infected and num not in arr:
                arr.append(num)

    return sorted(arr)
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 원래 풀던 풀이에 급하게 생각난 예외사항을 덧붙이느라 코드가 다소 난잡해진 문제였다.

* 이 문제에서 함정은 크게 두가지가 있었다.

	1. 확진자 역시 여러번 건물을 드나들수 있다.
	2. 처음부터 끝까지 건물에 박혀있는 사람이 있을수도 있다.

* 처음 이 문제를 보고 접근한 방식은 다음과 같았다.
	```
	확진자가 들어간 인덱스만 체크해서, 그 구간에 기록이 남은 사람을 잡자!
	```

* 그래서 inf_in과 inf_out을 통해 확진자의 출입 시간에 대한 인덱스를 확보했다.
	* 원래는 변수로 설정하려 했지만, ```확진자 역시 여러번 건물을 드나들수 있다```라는것이 떠올라 배열을 통해 확진자의 모든 출입 시간을 확보했다.

* ```history[inf_in[k]+1:inf_out[k]]```를 통해 확진자의 출입 시간대에 사람이 드나든 기록을 조사하여 제출했지만, 오답이 발생했다.

* 곰곰히 생각해보니, ```확진자가 들어오기 전부터 건물 안에 있고, 확진자가 나간 후에 나간 인원```이 있다면 위의 방법이 통하지 않을것이란 생각이 들었다.

	* 테스트 케이스를 만들어 돌려보니 예상대로 걸러내지 못했다.

* 각 시간대별 건물 내부에 있는 인원을 저장하는 배열인 in_man_per_time 배열을 생성하였고, 처음에 만들어준 답안에 더해주니 드디어 정답이 나왔다.



# 9. [제로베이스 프론트엔드 스쿨_CoronaKeepDistance]

* 코로나로 인해 거리 두기를 수행 중입니다.

* 사람들의 간격 lineUp은 사람을 나타내는 1과 비어있는 자리 0의 배열로 이루어져 있습니다.

* 코로나 심각도에 따라 거리두기 레벨 level이 주어질 때 방역수칙을 준수했는지 여부를 출력하는 함수, solution을 완성해주세요.

* 예를 들어, lineUp이 c이고, level이 2일 때, 결과는 true입니다.
	```
	첫 번째 사람 (index=0)과 두 번째 사람 (index=4)은 거리가 3만큼 떨어져 있으므로 방역수칙을 준수했습니다.

	두 번째 사람 (index=4)과 세 번째 사람 (index=7)은 거리가 2만큼 떨어져 있으므로 방역수칙을 준수했습니다.
	결과 : 방역수칙을 준수했습니다.
	```

## 제한 사항

* 두 사람 사이의 거리 즉, lineUp의 두 개의 1 사이의 0의 수가 K일 때, K >= level이면 방역수칙 준수 중입니다.

## 입력

* lineUp은 길이가 1 이상 1,000 이하의 배열입니다.

* lineUp은 0과 1의 요소로 이루어져 있습니다.

* level은 1 이상 1,000 이하의 정수입니다.

## 출력

* 방역수칙 준수 여부를 boolean 값으로 출력합니다.

## 풀이

```py
def solution(lineUp, level):

    flag = False
    cnt = 0
    for man in lineUp:
        if man == 1 and flag == False:
            flag = True
        elif man == 0 and flag == True:
            cnt += 1
        elif man == 1 and flag == True:
            if cnt < level:
                return False
                break
            cnt = 0

    return True
```

## 채점 결과

* 정답 (1.0/1.0)

## 리뷰

* 위의 7번 문제와 상당히 유사한 문제이고, 유사하게 풀렸다.

* 7번 문제와의 차이점은 이번 문제는 ```방역 수칙을 한번이라도 어기면 즉시 답이 나온다는것```이다.

* 7번 문제에서 언급했던것중 탐색이 끝났을때 flag를 False로 바꾸면 안됬었다고 한 이유가 이 문제에서 나왔는데, 다음과 같은 상황이 있었기 때문이다.

	```
	10001001, 방역 레벨 2단계

	10001 -> 거리 세칸. 방역수칙 이행. flag = False로 변경.
	1001 -> 거리 두칸. 방역수칙 불이행.
	하지만 man == 0 and flag == False이므로 탐색하지 않음.
	오류 발생.
	```

* 위의 상황처럼 한번 검사가 끝난 직후 바로 0이 연달아 나올때 flag가 꺼져있으면 문제가 발생할수 있다는 것이다.

	* 다만, 7번 문제의 경우 문제가 이진수였기에 그렇게 극단적인 경우의 수를 테스트케이스에 못넣은것 같았다.
	* 10010001을 10진수로 변환한 145가 7번 문제의 케이스에 있었다면 실수를 알아채는게 조금은 더 빨랐을지도 모르겠다.


# 10. [제로베이스 프론트엔드 스쿨_BrokenBridge]

* 넓이가 같은 n개의 나무판자를 붙여 만든 다리가 있습니다. 태풍의 영향으로 다리가 부서지고, 각 나무판자의 길이가 들쭉날쭉하게 잘려 나가서 더욱 튼튼한 철골 다리로 새로 만들기로 했습니다.
* 이때, 기존 다리의 나무판자 일부를 직사각형으로 잘라 재활용하고자 할 때, 그림 (b)는 다리 (a)에 남겨진 나무판자에서 잘라낼 수 있는 가장 넓은 직사각형이며, 그림 (c)와 같이 비스듬하게 자를 수 없습니다.
* 나무판자의 길이 배열 l이 주어질 때, 잘라낼 수 있는 직사각형의 최대 넓이를 구하는 함수, solution을 완성해주세요.


## 제한 사항

* 모든 나무판자의 넓이는 1이라고 가정합니다.

* 나무판자의 수직과 수평에 맞춰 잘라야 하며, 비스듬하게 자를 수 없습니다.

## 입력

* 왼쪽부터 순서대로 나무판자의 길이 배열 l이 주어집니다.

* l은 1 이상 10,000 이하의 정수로 이뤄진 배열입니다.

* 나무판자의 수 n은 1개 이상 10,000개 이하입니다.

## 출력

* 사용한 모든 전기 요금을 int 형식으로 출력합니다.

## 풀이

```py
def solution(l):
    # 각 구간별 넓이 측정
    # 가장 큰 값을 리턴
    max_len = 0
    # 각 구간의 넓이 저장 리스트
    arr = []
    for i in range(0,len(l)):
        cnt = 0
        for j in range(1,len(l)):
            if l[i] <= l[j]:
                cnt += 1
            elif l[i] > l[j]:
                arr.append(cnt * l[i])
                break

    return max(arr)

```

## 채점 결과

* 오답 (0.2/1.0)

## 리뷰

* 개인적으로, 분명 접근은 잘 했다 생각했는데 순전히 코드를 못짜서 망해버린 문제라고 생각한다.

* 처음 접근은 다음과 같이 진행했다.
	```
	1. 모든 구간을 선회하며 각 구간에서 나올수 있는 최대의 넓이를 찾는다.
	2. 각 구간에서 나오는 넓이중 최대값을 고른다.
	3. Profit! 
	```

* 각 구간에서 나올수 있는 최대의 넓이란, ```구간 첫 판자의 길이 * 구간 첫 판자보다 짧은게 나오기 전까지의 판자 개수```로 생각했고, 첫 테스트 케이스 역시 이런 접근법으로 금방 끝낼수 있었다.

* 하지만 테스트 케이스 ```[5, 10, 10, 10, 5, 50, 50, 50]```과 같은 배열에서 오류가 나기 시작해 결국 오류를 못잡고 시간 초과로 오답처리되었다.












