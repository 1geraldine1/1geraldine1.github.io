---
title: "제로베이스 20220330 코테 연습"
date: 2022-03-30T18:30:00-04:00
categories:
  - '2022-03 TIL'
tags:
  - '20220330'
  - '제로베이스'
  - '제로베이스 데이터사이언스 스쿨'
  - '코딩테스트 연습'

published: true
---

# 1. [소수 찾기](https://www.acmicpc.net/problem/1978)

* 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.

## 입력

* 첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.

## 출력

* 주어진 수들 중 소수의 개수를 출력한다.

## 풀이

```py
import sys

N = int(sys.stdin.readline())

nums = list(map(int,sys.stdin.readline().split()))

cnt = 0
cache = []
for n in nums:
    i = 2
    if n == 1:
        continue
    elif n == 2:
        cnt += 1
    else:
        while i < n:
            if n % i == 0:
                break
            elif n % i != 0 and i == n-1:
                cnt += 1
            i += 1

print(cnt)
```

## 채점 결과

* 정답

## 리뷰

* 각 숫자가 1000이하의 자연수이고, 배열의 최대 크기는 100 이하라는 조건이 붙어있으므로 단순 무식한 소수 구하기를 통해 문제를 해결할수 있었다.

* 만약 제시된 예시중에 크기 100의 배열에 900~1000의 수를 넣어놓는 식으로 최악의 시간복잡도를 제시할 경우, 실패가 날 확률이 대단히 높은 방법이다.

* 이에 대해서는 2번 문제에서 다룰 방식으로 푸는것이 정답이 될수있다.

# 2. [소수 구하기](https://www.acmicpc.net/problem/1929)

* M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.

## 출력

* 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

## 풀이

```py
import sys

M, N = list(map(int, sys.stdin.readline().split()))

a = [False,False] +[True] * (N-1)
primes = []

for i in range(2,N+1):
    if a[i]:
        primes.append(i)
        for j in range(2 * i, N+1,i):
            a[j] = False

for x in primes:
    if x >= M:
        print(x)
```

## 채점 결과

* 정답

## 리뷰

* 에라토스테네스의 체를 구현하여 푸는 방식이다.

* a는 0~N까지의 수가 소수인지 체크하기 위한 배열이다.
  * 첫 두 인덱스의 False는 0,1이 소수가 아님을 의미한다.

* 2~(N+1)의 인덱스를 순회하며, 각 인덱스에 True값이 들어가 있는 경우(체크되지 않은 소수인 경우) primes에 추가한다.

* 그 후 2*i부터 N+1 까지의 i의 배수에 대해 a값을 False로 변경하여 i의 배수가 인덱스로 나오더라도 조건에 걸리지 않도록 변경한다.(에라토스테네스의 체)

* 마지막으로, primes에서 M이상의 값만 출력하도록 하면 끝.




# 3. [AC](https://www.acmicpc.net/problem/5430)

* 선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 
* 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.

* 함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다.
* 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.

* 함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, "AB"는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 
  * 예를 들어, "RDD"는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.

* 배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.

* 각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.

* 다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)

* 다음 줄에는 [x1,...,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)

* 전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.

## 출력

* 각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다.

* 만약, 에러가 발생한 경우에는 error를 출력한다.

## 풀이

```py
# your code goes here

import sys

T = int(sys.stdin.readline())

for _ in range(0, T):
    p = sys.stdin.readline().strip()
    n = int(sys.stdin.readline())
    Xi = sys.stdin.readline().strip().strip('[').strip(']').split(',')
    Xi = list(map(int,Xi)) if Xi != [''] else []

    start = 0
    end = n

    flag = False
    error_flag = False
    for i in range(0, len(p)):
        if p[i] == 'R':
            flag = not flag
        elif p[i] == 'D':
            if start >= end:
                error_flag = not error_flag
                break
            else:
                if not flag:
                    start += 1
                else:
                    end -= 1

    if error_flag:
        print('error')
    else:
        if flag:
            Xi.reverse()
            target = Xi[n - end:n - start]
        else:
            target = Xi[start:end]

        a = '['
        for i in range(0,len(target)):
            a += str(target[i])
            if i < len(target)-1:
                a += ','
        a += ']'
        print(a)

```

## 채점 결과

* 정답

## 리뷰

* 단순해보이는 문제에 비해, 함정이 엄청나게 숨어있었던 문제였다.

* 크게 유의해야할 점은 다음과 같았다.
  1. 배열 인풋받을때 개행문자 조심. (strip()함수 사용)
  2. 빈 배열을 인풋받는 경우, list(map(int))를 통한 각 원소의 정수로 변환이 이루어지지 않으므로, 예외처리 해주어야 한다.
  3. 'R'함수의 사용시 실제로 배열을 뒤집어 저장하는 경우, O(n)의 시간복잡도가 소모되므로 reverse연산, [::-1]등을 사용한다면 시간 초과 발생.
  4. 마찬가지로 'D'함수의 사용시 실제 pop연산을 수행하는 경우 모든 배열을 한칸씩 당겨와야 하므로 O(N)의 시간복잡도 소모. 시간 초과 발생.
  5. 빈 배열에 'D'함수를 통해 pop연산을 할 경우, 결과물이 무조건 'error'라는 문자열로 출력되어야 함에 주의.
  6. 마지막으로, 출력시 리스트 형식이 아닌, 리스트를 닮은 str형식으로 출력되어야 함.
    * [1, 2, 3] (type : list) => 오답
    * [1,2,3] (type : str) => 정답


* 나의 경우, R함수 사용시 flag를 활성화하고 D함수가 사용될시 flag의 여부에 따라 가상 포인터 start와 end의 값을 조작하는것으로 시간복잡도를 최대한 줄였다.

* R함수가 홀수번 등장해 배열이 뒤집어진 경우, 배열은 ```Xi[n-end:n-start]```로 출력된다.
* R함수가 짝수번 등장해 배열이 뒤집어지지 않은 경우, 배열은 ```Xi[start:end]```로 출력된다.

* 마지막 리스트를 문자열로 변경하는 부분은 분명 개선점이 더 있을것같다.

